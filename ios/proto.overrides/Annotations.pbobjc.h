// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/api/annotations.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers.h>
#else
 #import "GPBProtocolBuffers.h"
#endif

#if GOOGLE_PROTOBUF_OBJC_VERSION < 30002
#error This file was generated by a newer version of protoc which is incompatible with your Protocol Buffer library sources.
#endif
#if 30002 < GOOGLE_PROTOBUF_OBJC_MIN_SUPPORTED_VERSION
#error This file was generated by an older version of protoc which is incompatible with your Protocol Buffer library sources.
#endif

// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

CF_EXTERN_C_BEGIN

NS_ASSUME_NONNULL_BEGIN

#pragma mark - GPBDescriptorRoot
@interface GPBDescriptorRoot : GPBRootObject
// The base class provides:
//   + (GPBExtensionRegistry *)extensionRegistry;
// which is an GPBExtensionRegistry that includes all the extensions defined by
// this file and all files that it depends on.
@end

@class GPBMethodOptions;

#pragma mark - GPBMethodOptions
typedef GPB_ENUM(GPBMethodOptions_FieldNumber) {
  GPBMethodOptions_FieldNumber_Deprecated = 33,
  GPBMethodOptions_FieldNumber_UninterpretedOptionArray = 999,
};
@interface GPBMethodOptions : GPBMessage
// Is this method deprecated?
// Depending on the target platform, this can emit Deprecated annotations
// for the method, or it will be completely ignored; in the very least,
// this is a formalization for deprecating methods.
@property(nonatomic, readwrite) BOOL hasDeprecated;
@property(nonatomic, readwrite) BOOL deprecated;
// The parser stores options it doesn't recognize here. See above.
// |uninterpretedOptionArray| contains |GPBUninterpretedOption|
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray *uninterpretedOptionArray;
@property(nonatomic, readonly) NSUInteger uninterpretedOptionArray_Count;
@end

#pragma mark - GPBUninterpretedOption
typedef GPB_ENUM(GPBUninterpretedOption_FieldNumber) {
  GPBUninterpretedOption_FieldNumber_NameArray = 2,
  GPBUninterpretedOption_FieldNumber_IdentifierValue = 3,
  GPBUninterpretedOption_FieldNumber_PositiveIntValue = 4,
  GPBUninterpretedOption_FieldNumber_NegativeIntValue = 5,
  GPBUninterpretedOption_FieldNumber_DoubleValue = 6,
  GPBUninterpretedOption_FieldNumber_StringValue = 7,
  GPBUninterpretedOption_FieldNumber_AggregateValue = 8,
};
// A message representing a option the parser does not recognize. This only
// appears in options protos created by the compiler::Parser class.
// DescriptorPool resolves these when building Descriptor objects. Therefore,
// options protos in descriptor objects (e.g. returned by Descriptor::options(),
// or produced by Descriptor::CopyTo()) will never have UninterpretedOptions
// in them.
@interface GPBUninterpretedOption : GPBMessage
// |nameArray| contains |GPBUninterpretedOption_NamePart|
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray *nameArray;
@property(nonatomic, readonly) NSUInteger nameArray_Count;
// The value of the uninterpreted option, in whatever type the tokenizer
// identified it as during parsing. Exactly one of these should be set.
@property(nonatomic, readwrite) BOOL hasIdentifierValue;
@property(nonatomic, readwrite, copy, null_resettable) NSString *identifierValue;
@property(nonatomic, readwrite) BOOL hasPositiveIntValue;
@property(nonatomic, readwrite) uint64_t positiveIntValue;
@property(nonatomic, readwrite) BOOL hasNegativeIntValue;
@property(nonatomic, readwrite) int64_t negativeIntValue;
@property(nonatomic, readwrite) BOOL hasDoubleValue;
@property(nonatomic, readwrite) double doubleValue;
@property(nonatomic, readwrite) BOOL hasStringValue;
@property(nonatomic, readwrite, copy, null_resettable) NSData *stringValue;
@property(nonatomic, readwrite) BOOL hasAggregateValue;
@property(nonatomic, readwrite, copy, null_resettable) NSString *aggregateValue;
@end
#pragma mark - GPBUninterpretedOption_NamePart
typedef GPB_ENUM(GPBUninterpretedOption_NamePart_FieldNumber) {
  GPBUninterpretedOption_NamePart_FieldNumber_NamePart = 1,
  GPBUninterpretedOption_NamePart_FieldNumber_IsExtension = 2,
};
// The name of the uninterpreted option.  Each string represents a segment in
// a dot-separated name.  is_extension is true iff a segment represents an
// extension (denoted with parentheses in options specs in .proto files).
// E.g.,{ ["foo", false], ["bar.baz", true], ["qux", false] } represents
// "foo.(bar.baz).qux".
@interface GPBUninterpretedOption_NamePart : GPBMessage
@property(nonatomic, readwrite) BOOL hasNamePart;
@property(nonatomic, readwrite, copy, null_resettable) NSString *namePart;
@property(nonatomic, readwrite) BOOL hasIsExtension;
@property(nonatomic, readwrite) BOOL isExtension;
@end

#pragma mark - AnnotationsRoot

/**
 * Exposes the extension registry for this file.
 *
 * The base class provides:
 * @code
 *   + (GPBExtensionRegistry *)extensionRegistry;
 * @endcode
 * which is a @c GPBExtensionRegistry that includes all the extensions defined by
 * this file and all files that it depends on.
 **/
@interface AnnotationsRoot : GPBRootObject
@end

@interface AnnotationsRoot (DynamicMethods)
/** See `HttpRule`. */
+ (GPBExtensionDescriptor *)HTTP;
@end

NS_ASSUME_NONNULL_END

CF_EXTERN_C_END

#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
